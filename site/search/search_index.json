{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Shannon Bench","text":"<p>Shannon Bench is a radio channel simulation and benchmarking tool.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Channel Simulation: Simulate various radio channels including AWGN, Rayleigh fading, and more.</li> <li>Benchmarking: Evaluate the performance of different modulation and coding schemes.</li> <li>Extensible: Easy to add new channel models and evaluation metrics.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Shannon Bench, install the package and run the simulation:</p> <pre><code>pip install shannon-bench\n</code></pre> <p>See the API Reference for detailed documentation of the available modules and classes.</p>"},{"location":"api/","title":"API Reference","text":"<p>This page provides detailed documentation for the <code>shannon_bench</code> package.</p>"},{"location":"api/#channel-simulation","title":"Channel Simulation","text":""},{"location":"api/#shannon_bench.simulator.channels","title":"<code>shannon_bench.simulator.channels</code>","text":"<p>Standard library of pre-configured channel conditions.</p> <p>This module provides factory functions and constants for common radio channel scenarios, organized by propagation environment (HF, VHF/UHF, Satellite, EME). Each preset returns a list of ChannelImpairment objects that can be used with ChannelSimulator.</p> Typical Usage <pre><code>from shannon_bench.simulator.channels import hf\nfrom shannon_bench.simulator.transmission_system import ChannelSimulator\n\n# Use factory function with custom parameters\nimpairments = hf.poor(snr_db=8.0, doppler_hz=1.5)\nchannel = ChannelSimulator(impairments, sample_rate=8000)\n\n# Or use pre-configured preset\nchannel = ChannelSimulator(hf.ITU_R_POOR, sample_rate=8000)\n</code></pre> References <ul> <li>ITU-R Rec. F.1487: \"Testing of HF modems with bandwidths of up to   about 12 kHz using ionospheric channel simulators\"</li> <li>3GPP TS 36.101: \"User Equipment (UE) radio transmission and reception\"</li> <li>CCIR Report 252-2: \"Factors affecting the choice of frequencies for   circuits using ionospheric propagation\"</li> </ul>"},{"location":"api/#shannon_bench.simulator.channels.ChannelPreset","title":"<code>ChannelPreset</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A named channel configuration with metadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Human-readable preset name.</p> <code>description</code> <code>str</code> <p>Detailed description of channel characteristics.</p> <code>impairments</code> <code>Sequence[ChannelImpairment]</code> <p>List of impairments to apply.</p> <code>typical_sample_rate</code> <code>int</code> <p>Recommended sample rate in Hz for this channel.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class ChannelPreset(BaseModel):\n  \"\"\"A named channel configuration with metadata.\n\n  Attributes:\n    name: Human-readable preset name.\n    description: Detailed description of channel characteristics.\n    impairments: List of impairments to apply.\n    typical_sample_rate: Recommended sample rate in Hz for this channel.\n  \"\"\"\n\n  name: str\n  description: str\n  impairments: Sequence[ChannelImpairment]\n  typical_sample_rate: int\n\n  model_config = {\"frozen\": True, \"arbitrary_types_allowed\": True}\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.awgn","title":"<code>awgn</code>","text":"<p>AWGN-only channel presets for baseline testing.</p> <p>Pure additive white Gaussian noise without fading or other impairments.</p> <p>Useful for:</p> <ul> <li>Baseline performance measurement</li> <li>Codec testing</li> <li>SNR threshold determination</li> </ul> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class awgn:  # noqa: N801\n  \"\"\"AWGN-only channel presets for baseline testing.\n\n  Pure additive white Gaussian noise without fading or other impairments.\n\n  Useful for:\n\n  - Baseline performance measurement\n  - Codec testing\n  - SNR threshold determination\n  \"\"\"\n\n  TYPICAL_SAMPLE_RATE: int = 48000  # Hz (arbitrary, works at any rate)\n\n  # Pre-configured presets (assigned below)\n  SNR_30DB: ChannelPreset\n  SNR_20DB: ChannelPreset\n  SNR_10DB: ChannelPreset\n  SNR_0DB: ChannelPreset\n\n  @staticmethod\n  def only(snr_db: float) -&gt; list[ChannelImpairment]:\n    \"\"\"Pure AWGN channel at specified SNR.\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB.\n\n    Returns:\n      List containing only AWGN impairment.\n    \"\"\"\n    return [AWGN(snr_db=snr_db)]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.awgn.only","title":"<code>only(snr_db)</code>  <code>staticmethod</code>","text":"<p>Pure AWGN channel at specified SNR.</p> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB.</p> required <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List containing only AWGN impairment.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef only(snr_db: float) -&gt; list[ChannelImpairment]:\n  \"\"\"Pure AWGN channel at specified SNR.\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB.\n\n  Returns:\n    List containing only AWGN impairment.\n  \"\"\"\n  return [AWGN(snr_db=snr_db)]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.eme","title":"<code>eme</code>","text":"<p>Earth-Moon-Earth (EME) moonbounce channel presets.</p> <p>EME channels are characterized by:</p> <ul> <li>Extremely long path (768,000 km round trip)</li> <li>Very high path loss (~250-270 dB at VHF/UHF)</li> <li>Libration fading (Doppler spread from lunar motion: 0.5-2 Hz)</li> <li>Polarization rotation (Faraday effect in ionosphere)</li> <li>Typical frequencies: 144 MHz, 432 MHz, 1296 MHz</li> <li>Typical sample rate: 48 kHz</li> </ul> References <ul> <li>ARRL Handbook: \"EME Communications\"</li> <li>W1GHZ: \"Microwave Antenna Book\"</li> <li>VK3UM: \"EME Calculator\"</li> </ul> <p>Note: Path loss is not modeled here (handled by link budget).</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class eme:  # noqa: N801\n  \"\"\"Earth-Moon-Earth (EME) moonbounce channel presets.\n\n  EME channels are characterized by:\n\n  - Extremely long path (768,000 km round trip)\n  - Very high path loss (~250-270 dB at VHF/UHF)\n  - Libration fading (Doppler spread from lunar motion: 0.5-2 Hz)\n  - Polarization rotation (Faraday effect in ionosphere)\n  - Typical frequencies: 144 MHz, 432 MHz, 1296 MHz\n  - Typical sample rate: 48 kHz\n\n  References:\n    - [ARRL Handbook: \"EME Communications\"](https://www.arrl.org/news/handbook-101-a-new-generation-of-amateur-radio)\n    - [W1GHZ: \"Microwave Antenna Book\"](https://www.w1ghz.org/antbook/contents.htm)\n    - [VK3UM: \"EME Calculator\"](https://www.vk5dj.com/doug.html)\n\n  Note: Path loss is not modeled here (handled by link budget).\n  \"\"\"\n\n  TYPICAL_SAMPLE_RATE: int = 48000  # Hz\n\n  # Pre-configured presets (assigned below)\n  SMOOTH_MOON: ChannelPreset\n  ROUGH_MOON: ChannelPreset\n  DEGRADED: ChannelPreset\n\n  @staticmethod\n  def smooth_moon(\n    snr_db: float = -3.0,\n    doppler_hz: float = 0.5,\n    freq_offset_hz: float = 200.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"EME with smooth lunar surface reflection.\n\n    Typical for:\n\n    - Specular reflection from smooth mare regions\n    - Low libration fading\n    - Optimal moon position (low declination rate)\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: -3 dB, typical for EME).\n      doppler_hz: Libration Doppler spread in Hz (default: 0.5 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 200 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RicianFading(doppler_hz=doppler_hz, k_factor_db=6.0),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def rough_moon(\n    snr_db: float = -5.0,\n    doppler_hz: float = 1.5,\n    freq_offset_hz: float = 200.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"EME with rough lunar surface scattering.\n\n    Typical for:\n\n    - Diffuse scattering from rough highland regions\n    - Higher libration fading\n    - Rapid moon declination changes\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: -5 dB).\n      doppler_hz: Libration Doppler spread in Hz (default: 1.5 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 200 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RayleighFading(doppler_hz=doppler_hz),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def degraded(\n    snr_db: float = -8.0,\n    doppler_hz: float = 2.0,\n    freq_offset_hz: float = 250.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"EME with degraded conditions.\n\n    Typical for:\n\n    - Low moon elevation (&lt; 10\u00b0)\n    - High atmospheric noise\n    - Suboptimal antenna pointing\n    - Ionospheric disturbances (Faraday rotation)\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: -8 dB).\n      doppler_hz: Libration Doppler spread in Hz (default: 2 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 250 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RayleighFading(doppler_hz=doppler_hz),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.eme.degraded","title":"<code>degraded(snr_db=-8.0, doppler_hz=2.0, freq_offset_hz=250.0)</code>  <code>staticmethod</code>","text":"<p>EME with degraded conditions.</p> <p>Typical for:</p> <ul> <li>Low moon elevation (&lt; 10\u00b0)</li> <li>High atmospheric noise</li> <li>Suboptimal antenna pointing</li> <li>Ionospheric disturbances (Faraday rotation)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: -8 dB).</p> <code>-8.0</code> <code>doppler_hz</code> <code>float</code> <p>Libration Doppler spread in Hz (default: 2 Hz).</p> <code>2.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 250 Hz).</p> <code>250.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef degraded(\n  snr_db: float = -8.0,\n  doppler_hz: float = 2.0,\n  freq_offset_hz: float = 250.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"EME with degraded conditions.\n\n  Typical for:\n\n  - Low moon elevation (&lt; 10\u00b0)\n  - High atmospheric noise\n  - Suboptimal antenna pointing\n  - Ionospheric disturbances (Faraday rotation)\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: -8 dB).\n    doppler_hz: Libration Doppler spread in Hz (default: 2 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 250 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RayleighFading(doppler_hz=doppler_hz),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.eme.rough_moon","title":"<code>rough_moon(snr_db=-5.0, doppler_hz=1.5, freq_offset_hz=200.0)</code>  <code>staticmethod</code>","text":"<p>EME with rough lunar surface scattering.</p> <p>Typical for:</p> <ul> <li>Diffuse scattering from rough highland regions</li> <li>Higher libration fading</li> <li>Rapid moon declination changes</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: -5 dB).</p> <code>-5.0</code> <code>doppler_hz</code> <code>float</code> <p>Libration Doppler spread in Hz (default: 1.5 Hz).</p> <code>1.5</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 200 Hz).</p> <code>200.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef rough_moon(\n  snr_db: float = -5.0,\n  doppler_hz: float = 1.5,\n  freq_offset_hz: float = 200.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"EME with rough lunar surface scattering.\n\n  Typical for:\n\n  - Diffuse scattering from rough highland regions\n  - Higher libration fading\n  - Rapid moon declination changes\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: -5 dB).\n    doppler_hz: Libration Doppler spread in Hz (default: 1.5 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 200 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RayleighFading(doppler_hz=doppler_hz),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.eme.smooth_moon","title":"<code>smooth_moon(snr_db=-3.0, doppler_hz=0.5, freq_offset_hz=200.0)</code>  <code>staticmethod</code>","text":"<p>EME with smooth lunar surface reflection.</p> <p>Typical for:</p> <ul> <li>Specular reflection from smooth mare regions</li> <li>Low libration fading</li> <li>Optimal moon position (low declination rate)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: -3 dB, typical for EME).</p> <code>-3.0</code> <code>doppler_hz</code> <code>float</code> <p>Libration Doppler spread in Hz (default: 0.5 Hz).</p> <code>0.5</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 200 Hz).</p> <code>200.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef smooth_moon(\n  snr_db: float = -3.0,\n  doppler_hz: float = 0.5,\n  freq_offset_hz: float = 200.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"EME with smooth lunar surface reflection.\n\n  Typical for:\n\n  - Specular reflection from smooth mare regions\n  - Low libration fading\n  - Optimal moon position (low declination rate)\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: -3 dB, typical for EME).\n    doppler_hz: Libration Doppler spread in Hz (default: 0.5 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 200 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RicianFading(doppler_hz=doppler_hz, k_factor_db=6.0),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf","title":"<code>hf</code>","text":"<p>HF (3-30 MHz) channel presets for ionospheric propagation.</p> <p>HF channels are characterized by: - Ionospheric reflection (skywave propagation) - Multipath fading with Doppler spread (0.1-5 Hz typical) - Frequency-selective fading - SSB voice bandwidth: 300-2700 Hz - Typical sample rate: 8 kHz</p> References <ul> <li>ITU-R Rec. F.1487 (HF channel models)</li> <li>CCIR Report 252-2 (HF propagation factors)</li> </ul> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class hf:  # noqa: N801\n  \"\"\"HF (3-30 MHz) channel presets for ionospheric propagation.\n\n  HF channels are characterized by:\n  - Ionospheric reflection (skywave propagation)\n  - Multipath fading with Doppler spread (0.1-5 Hz typical)\n  - Frequency-selective fading\n  - SSB voice bandwidth: 300-2700 Hz\n  - Typical sample rate: 8 kHz\n\n  References:\n    - ITU-R Rec. F.1487 (HF channel models)\n    - CCIR Report 252-2 (HF propagation factors)\n  \"\"\"\n\n  TYPICAL_SAMPLE_RATE: int = 8000  # Hz\n\n  # Pre-configured presets (assigned below)\n  ITU_R_EXCELLENT: ChannelPreset\n  ITU_R_GOOD: ChannelPreset\n  ITU_R_MODERATE: ChannelPreset\n  ITU_R_POOR: ChannelPreset\n  NVIS: ChannelPreset\n\n  @staticmethod\n  def excellent(\n    snr_db: float = 30.0, freq_offset_hz: float = 1.0\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Excellent HF conditions: minimal fading, very high SNR.\n\n    Typical for:\n\n    - Short-range skywave (&lt; 500 km)\n    - Quiet ionospheric conditions\n    - Strong signal paths\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 30 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 1 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def good(\n    snr_db: float = 20.0,\n    doppler_hz: float = 0.5,\n    freq_offset_hz: float = 2.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Good HF conditions: light fading, high SNR.\n\n    Typical for:\n\n    - Stable mid-range paths (500-2000 km)\n    - Daytime propagation\n    - Low geomagnetic activity\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 0.5 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 2 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n      # ITU-R F.1487 \"Good\" condition: 2 taps, 0.5ms delay spread\n      TappedDelayLine(\n        taps=[\n          TapProfile(\n            delay_sec=0.0,\n            power_db=0.0,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=0.0005,  # 0.5 ms\n            power_db=0.0,  # Equal power\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n        ]\n      ),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def moderate(\n    snr_db: float = 12.0,\n    doppler_hz: float = 1.0,\n    freq_offset_hz: float = 5.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Moderate HF conditions: moderate fading and noise.\n\n    Typical for:\n\n    - Long-range paths (2000-4000 km)\n    - Nighttime propagation\n    - Moderate geomagnetic activity\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 12 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 1 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 5 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n      # ITU-R F.1487 \"Moderate\" condition: 2 taps, 1ms delay spread\n      TappedDelayLine(\n        taps=[\n          TapProfile(\n            delay_sec=0.0,\n            power_db=0.0,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=0.001,  # 1 ms\n            power_db=0.0,  # Equal power\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n        ]\n      ),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def poor(\n    snr_db: float = 5.0,\n    doppler_hz: float = 2.0,\n    freq_offset_hz: float = 10.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Poor HF conditions: heavy fading, low SNR.\n\n    Typical for:\n\n    - Very long range (&gt; 4000 km)\n    - Disturbed ionospheric conditions\n    - High geomagnetic activity (K-index &gt; 5)\n    - Polar paths (aurora)\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 5 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 2 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n      # ITU-R F.1487 \"Poor\" condition: 2 taps, 2ms delay spread\n      TappedDelayLine(\n        taps=[\n          TapProfile(\n            delay_sec=0.0,\n            power_db=0.0,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=0.002,  # 2 ms\n            power_db=0.0,  # Equal power\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n        ]\n      ),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def nvis(\n    snr_db: float = 15.0,\n    doppler_hz: float = 0.2,\n    freq_offset_hz: float = 1.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Near Vertical Incidence Skywave (NVIS) conditions.\n\n    NVIS uses high-angle radiation (&gt; 75\u00b0) for regional coverage (0-400 km).\n    Characterized by:\n\n    - Very low Doppler spread\n    - Stable propagation\n    - Typical frequencies: 2-10 MHz\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 0.2 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 1 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n      RayleighFading(doppler_hz=doppler_hz),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf.excellent","title":"<code>excellent(snr_db=30.0, freq_offset_hz=1.0)</code>  <code>staticmethod</code>","text":"<p>Excellent HF conditions: minimal fading, very high SNR.</p> <p>Typical for:</p> <ul> <li>Short-range skywave (&lt; 500 km)</li> <li>Quiet ionospheric conditions</li> <li>Strong signal paths</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 30 dB).</p> <code>30.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 1 Hz).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef excellent(\n  snr_db: float = 30.0, freq_offset_hz: float = 1.0\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Excellent HF conditions: minimal fading, very high SNR.\n\n  Typical for:\n\n  - Short-range skywave (&lt; 500 km)\n  - Quiet ionospheric conditions\n  - Strong signal paths\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 30 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 1 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf.good","title":"<code>good(snr_db=20.0, doppler_hz=0.5, freq_offset_hz=2.0)</code>  <code>staticmethod</code>","text":"<p>Good HF conditions: light fading, high SNR.</p> <p>Typical for:</p> <ul> <li>Stable mid-range paths (500-2000 km)</li> <li>Daytime propagation</li> <li>Low geomagnetic activity</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 20 dB).</p> <code>20.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 0.5 Hz).</p> <code>0.5</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 2 Hz).</p> <code>2.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef good(\n  snr_db: float = 20.0,\n  doppler_hz: float = 0.5,\n  freq_offset_hz: float = 2.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Good HF conditions: light fading, high SNR.\n\n  Typical for:\n\n  - Stable mid-range paths (500-2000 km)\n  - Daytime propagation\n  - Low geomagnetic activity\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 0.5 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 2 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n    # ITU-R F.1487 \"Good\" condition: 2 taps, 0.5ms delay spread\n    TappedDelayLine(\n      taps=[\n        TapProfile(\n          delay_sec=0.0,\n          power_db=0.0,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=0.0005,  # 0.5 ms\n          power_db=0.0,  # Equal power\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n      ]\n    ),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf.moderate","title":"<code>moderate(snr_db=12.0, doppler_hz=1.0, freq_offset_hz=5.0)</code>  <code>staticmethod</code>","text":"<p>Moderate HF conditions: moderate fading and noise.</p> <p>Typical for:</p> <ul> <li>Long-range paths (2000-4000 km)</li> <li>Nighttime propagation</li> <li>Moderate geomagnetic activity</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 12 dB).</p> <code>12.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 1 Hz).</p> <code>1.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 5 Hz).</p> <code>5.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef moderate(\n  snr_db: float = 12.0,\n  doppler_hz: float = 1.0,\n  freq_offset_hz: float = 5.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Moderate HF conditions: moderate fading and noise.\n\n  Typical for:\n\n  - Long-range paths (2000-4000 km)\n  - Nighttime propagation\n  - Moderate geomagnetic activity\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 12 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 1 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 5 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n    # ITU-R F.1487 \"Moderate\" condition: 2 taps, 1ms delay spread\n    TappedDelayLine(\n      taps=[\n        TapProfile(\n          delay_sec=0.0,\n          power_db=0.0,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=0.001,  # 1 ms\n          power_db=0.0,  # Equal power\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n      ]\n    ),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf.nvis","title":"<code>nvis(snr_db=15.0, doppler_hz=0.2, freq_offset_hz=1.0)</code>  <code>staticmethod</code>","text":"<p>Near Vertical Incidence Skywave (NVIS) conditions.</p> <p>NVIS uses high-angle radiation (&gt; 75\u00b0) for regional coverage (0-400 km). Characterized by:</p> <ul> <li>Very low Doppler spread</li> <li>Stable propagation</li> <li>Typical frequencies: 2-10 MHz</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 15 dB).</p> <code>15.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 0.2 Hz).</p> <code>0.2</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 1 Hz).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef nvis(\n  snr_db: float = 15.0,\n  doppler_hz: float = 0.2,\n  freq_offset_hz: float = 1.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Near Vertical Incidence Skywave (NVIS) conditions.\n\n  NVIS uses high-angle radiation (&gt; 75\u00b0) for regional coverage (0-400 km).\n  Characterized by:\n\n  - Very low Doppler spread\n  - Stable propagation\n  - Typical frequencies: 2-10 MHz\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 0.2 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 1 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n    RayleighFading(doppler_hz=doppler_hz),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.hf.poor","title":"<code>poor(snr_db=5.0, doppler_hz=2.0, freq_offset_hz=10.0)</code>  <code>staticmethod</code>","text":"<p>Poor HF conditions: heavy fading, low SNR.</p> <p>Typical for:</p> <ul> <li>Very long range (&gt; 4000 km)</li> <li>Disturbed ionospheric conditions</li> <li>High geomagnetic activity (K-index &gt; 5)</li> <li>Polar paths (aurora)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 5 dB).</p> <code>5.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 2 Hz).</p> <code>2.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 10 Hz).</p> <code>10.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef poor(\n  snr_db: float = 5.0,\n  doppler_hz: float = 2.0,\n  freq_offset_hz: float = 10.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Poor HF conditions: heavy fading, low SNR.\n\n  Typical for:\n\n  - Very long range (&gt; 4000 km)\n  - Disturbed ionospheric conditions\n  - High geomagnetic activity (K-index &gt; 5)\n  - Polar paths (aurora)\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 5 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 2 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    SSBFilter(low_cutoff_hz=300.0, high_cutoff_hz=2700.0),\n    # ITU-R F.1487 \"Poor\" condition: 2 taps, 2ms delay spread\n    TappedDelayLine(\n      taps=[\n        TapProfile(\n          delay_sec=0.0,\n          power_db=0.0,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=0.002,  # 2 ms\n          power_db=0.0,  # Equal power\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n      ]\n    ),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.satellite","title":"<code>satellite</code>","text":"<p>Satellite channel presets for LEO, MEO, and GEO orbits.</p> <p>Satellite channels are characterized by:</p> <ul> <li>High Doppler shift (LEO: up to \u00b13 kHz at UHF)</li> <li>Possible Rician fading (strong LOS + multipath)</li> <li>Long propagation delays (not modeled here)</li> <li>Typical sample rate: 48 kHz or higher</li> </ul> References <ul> <li>ITU-R S.1428 (Satellite channel models)</li> <li>CCSDS 401.0-B (Radio Frequency and Modulation Systems)</li> </ul> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class satellite:  # noqa: N801\n  \"\"\"Satellite channel presets for LEO, MEO, and GEO orbits.\n\n  Satellite channels are characterized by:\n\n  - High Doppler shift (LEO: up to \u00b13 kHz at UHF)\n  - Possible Rician fading (strong LOS + multipath)\n  - Long propagation delays (not modeled here)\n  - Typical sample rate: 48 kHz or higher\n\n  References:\n    - ITU-R S.1428 (Satellite channel models)\n    - CCSDS 401.0-B (Radio Frequency and Modulation Systems)\n  \"\"\"\n\n  TYPICAL_SAMPLE_RATE: int = 48000  # Hz\n\n  # Pre-configured presets (assigned below)\n  LEO_CLEAR: ChannelPreset\n  LEO_FADED: ChannelPreset\n  GEO: ChannelPreset\n\n  @staticmethod\n  def leo_clear(\n    snr_db: float = 20.0,\n    doppler_hz: float = 10.0,\n    k_factor_db: float = 10.0,\n    freq_offset_hz: float = 100.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"LEO satellite, clear conditions: strong LOS, high Doppler.\n\n    Typical for:\n\n    - Low Earth Orbit (400-2000 km altitude)\n    - Clear sky, high elevation angle\n    - Strong line-of-sight component\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n      doppler_hz: Doppler spread in Hz (default: 10 Hz).\n      k_factor_db: Rician K-factor in dB (default: 10 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 100 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def leo_faded(\n    snr_db: float = 12.0,\n    doppler_hz: float = 15.0,\n    k_factor_db: float = 3.0,\n    freq_offset_hz: float = 150.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"LEO satellite, faded conditions: multipath, lower K-factor.\n\n    Typical for:\n\n    - Low elevation angles (&lt; 20\u00b0)\n    - Urban/suburban ground stations (multipath)\n    - Partial obstruction\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 12 dB).\n      doppler_hz: Doppler spread in Hz (default: 15 Hz).\n      k_factor_db: Rician K-factor in dB (default: 3 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 150 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def geo(\n    snr_db: float = 15.0,\n    freq_offset_hz: float = 10.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"GEO satellite: minimal Doppler, AWGN-dominated.\n\n    Typical for:\n\n    - Geostationary orbit (35,786 km altitude)\n    - Fixed ground station\n    - Stable propagation path\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.satellite.geo","title":"<code>geo(snr_db=15.0, freq_offset_hz=10.0)</code>  <code>staticmethod</code>","text":"<p>GEO satellite: minimal Doppler, AWGN-dominated.</p> <p>Typical for:</p> <ul> <li>Geostationary orbit (35,786 km altitude)</li> <li>Fixed ground station</li> <li>Stable propagation path</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 15 dB).</p> <code>15.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 10 Hz).</p> <code>10.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef geo(\n  snr_db: float = 15.0,\n  freq_offset_hz: float = 10.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"GEO satellite: minimal Doppler, AWGN-dominated.\n\n  Typical for:\n\n  - Geostationary orbit (35,786 km altitude)\n  - Fixed ground station\n  - Stable propagation path\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.satellite.leo_clear","title":"<code>leo_clear(snr_db=20.0, doppler_hz=10.0, k_factor_db=10.0, freq_offset_hz=100.0)</code>  <code>staticmethod</code>","text":"<p>LEO satellite, clear conditions: strong LOS, high Doppler.</p> <p>Typical for:</p> <ul> <li>Low Earth Orbit (400-2000 km altitude)</li> <li>Clear sky, high elevation angle</li> <li>Strong line-of-sight component</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 20 dB).</p> <code>20.0</code> <code>doppler_hz</code> <code>float</code> <p>Doppler spread in Hz (default: 10 Hz).</p> <code>10.0</code> <code>k_factor_db</code> <code>float</code> <p>Rician K-factor in dB (default: 10 dB).</p> <code>10.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 100 Hz).</p> <code>100.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef leo_clear(\n  snr_db: float = 20.0,\n  doppler_hz: float = 10.0,\n  k_factor_db: float = 10.0,\n  freq_offset_hz: float = 100.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"LEO satellite, clear conditions: strong LOS, high Doppler.\n\n  Typical for:\n\n  - Low Earth Orbit (400-2000 km altitude)\n  - Clear sky, high elevation angle\n  - Strong line-of-sight component\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n    doppler_hz: Doppler spread in Hz (default: 10 Hz).\n    k_factor_db: Rician K-factor in dB (default: 10 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 100 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.satellite.leo_faded","title":"<code>leo_faded(snr_db=12.0, doppler_hz=15.0, k_factor_db=3.0, freq_offset_hz=150.0)</code>  <code>staticmethod</code>","text":"<p>LEO satellite, faded conditions: multipath, lower K-factor.</p> <p>Typical for:</p> <ul> <li>Low elevation angles (&lt; 20\u00b0)</li> <li>Urban/suburban ground stations (multipath)</li> <li>Partial obstruction</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 12 dB).</p> <code>12.0</code> <code>doppler_hz</code> <code>float</code> <p>Doppler spread in Hz (default: 15 Hz).</p> <code>15.0</code> <code>k_factor_db</code> <code>float</code> <p>Rician K-factor in dB (default: 3 dB).</p> <code>3.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 150 Hz).</p> <code>150.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef leo_faded(\n  snr_db: float = 12.0,\n  doppler_hz: float = 15.0,\n  k_factor_db: float = 3.0,\n  freq_offset_hz: float = 150.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"LEO satellite, faded conditions: multipath, lower K-factor.\n\n  Typical for:\n\n  - Low elevation angles (&lt; 20\u00b0)\n  - Urban/suburban ground stations (multipath)\n  - Partial obstruction\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 12 dB).\n    doppler_hz: Doppler spread in Hz (default: 15 Hz).\n    k_factor_db: Rician K-factor in dB (default: 3 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 150 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.vhf","title":"<code>vhf</code>","text":"<p>VHF/UHF (30-3000 MHz) channel presets for terrestrial mobile/fixed.</p> <p>VHF/UHF channels are characterized by:</p> <ul> <li>Line-of-sight or ground reflection propagation</li> <li>Mobile Doppler (10-200 Hz at vehicular speeds)</li> <li>Rayleigh (NLOS) or Rician (LOS) fading</li> <li>Typical sample rate: 48 kHz</li> </ul> References <ul> <li>3GPP TS 36.101 (LTE channel models)</li> <li>ITU-R M.1225 (Mobile channel models)</li> </ul> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>class vhf:  # noqa: N801\n  \"\"\"VHF/UHF (30-3000 MHz) channel presets for terrestrial mobile/fixed.\n\n  VHF/UHF channels are characterized by:\n\n  - Line-of-sight or ground reflection propagation\n  - Mobile Doppler (10-200 Hz at vehicular speeds)\n  - Rayleigh (NLOS) or Rician (LOS) fading\n  - Typical sample rate: 48 kHz\n\n  References:\n    - 3GPP TS 36.101 (LTE channel models)\n    - ITU-R M.1225 (Mobile channel models)\n  \"\"\"\n\n  TYPICAL_SAMPLE_RATE: int = 48000  # Hz\n\n  # Pre-configured presets (assigned below)\n  FIXED_LOS: ChannelPreset\n  MOBILE_URBAN: ChannelPreset\n  MOBILE_RURAL: ChannelPreset\n  MOBILE_PEDESTRIAN: ChannelPreset\n\n  @staticmethod\n  def fixed_los(\n    snr_db: float = 25.0, freq_offset_hz: float = 5.0\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Fixed line-of-sight: minimal fading, AWGN-dominated.\n\n    Typical for:\n\n    - Point-to-point links\n    - Base station to fixed terminal\n    - Clear line-of-sight paths\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 25 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 5 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def mobile_urban(\n    snr_db: float = 15.0,\n    doppler_hz: float = 100.0,\n    freq_offset_hz: float = 50.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Mobile urban: heavy Rayleigh fading, high Doppler.\n\n    Typical for:\n\n    - Urban vehicular (60 km/h at 900 MHz \u2192 ~50 Hz Doppler)\n    - Dense multipath (buildings, reflections)\n    - Non-line-of-sight (NLOS)\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 100 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 50 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      # 3GPP EVA (Extended Vehicular A) model - simplified to 5 main taps\n      TappedDelayLine(\n        taps=[\n          TapProfile(\n            delay_sec=0.0,\n            power_db=0.0,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=30e-9,\n            power_db=-1.5,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=150e-9,\n            power_db=-1.4,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=310e-9,\n            power_db=-3.6,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n          TapProfile(\n            delay_sec=710e-9,\n            power_db=-9.1,\n            fading_model=RayleighFading(doppler_hz=doppler_hz),\n          ),\n        ]\n      ),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def mobile_rural(\n    snr_db: float = 20.0,\n    doppler_hz: float = 20.0,\n    k_factor_db: float = 6.0,\n    freq_offset_hz: float = 20.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Mobile rural: Rician fading with LOS component.\n\n    Typical for:\n\n    - Rural/suburban vehicular\n    - Partial line-of-sight\n    - Lower Doppler (lower speeds or frequencies)\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 20 Hz).\n      k_factor_db: Rician K-factor in dB (default: 6 dB).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 20 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n\n  @staticmethod\n  def mobile_pedestrian(\n    snr_db: float = 18.0,\n    doppler_hz: float = 5.0,\n    freq_offset_hz: float = 10.0,\n  ) -&gt; list[ChannelImpairment]:\n    \"\"\"Mobile pedestrian: low Doppler, moderate fading.\n\n    Typical for:\n\n    - Pedestrian speeds (5 km/h at 2 GHz \u2192 ~9 Hz Doppler)\n    - Indoor/outdoor transitions\n    - Handheld devices\n\n    Args:\n      snr_db: Signal-to-noise ratio in dB (default: 18 dB).\n      doppler_hz: Maximum Doppler shift in Hz (default: 5 Hz).\n      freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n    Returns:\n      List of channel impairments.\n    \"\"\"\n    return [\n      RayleighFading(doppler_hz=doppler_hz),\n      FreqOffset(offset_hz=freq_offset_hz),\n      AWGN(snr_db=snr_db),\n    ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.vhf.fixed_los","title":"<code>fixed_los(snr_db=25.0, freq_offset_hz=5.0)</code>  <code>staticmethod</code>","text":"<p>Fixed line-of-sight: minimal fading, AWGN-dominated.</p> <p>Typical for:</p> <ul> <li>Point-to-point links</li> <li>Base station to fixed terminal</li> <li>Clear line-of-sight paths</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 25 dB).</p> <code>25.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 5 Hz).</p> <code>5.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef fixed_los(\n  snr_db: float = 25.0, freq_offset_hz: float = 5.0\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Fixed line-of-sight: minimal fading, AWGN-dominated.\n\n  Typical for:\n\n  - Point-to-point links\n  - Base station to fixed terminal\n  - Clear line-of-sight paths\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 25 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 5 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.vhf.mobile_pedestrian","title":"<code>mobile_pedestrian(snr_db=18.0, doppler_hz=5.0, freq_offset_hz=10.0)</code>  <code>staticmethod</code>","text":"<p>Mobile pedestrian: low Doppler, moderate fading.</p> <p>Typical for:</p> <ul> <li>Pedestrian speeds (5 km/h at 2 GHz \u2192 ~9 Hz Doppler)</li> <li>Indoor/outdoor transitions</li> <li>Handheld devices</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 18 dB).</p> <code>18.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 5 Hz).</p> <code>5.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 10 Hz).</p> <code>10.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef mobile_pedestrian(\n  snr_db: float = 18.0,\n  doppler_hz: float = 5.0,\n  freq_offset_hz: float = 10.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Mobile pedestrian: low Doppler, moderate fading.\n\n  Typical for:\n\n  - Pedestrian speeds (5 km/h at 2 GHz \u2192 ~9 Hz Doppler)\n  - Indoor/outdoor transitions\n  - Handheld devices\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 18 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 5 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 10 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RayleighFading(doppler_hz=doppler_hz),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.vhf.mobile_rural","title":"<code>mobile_rural(snr_db=20.0, doppler_hz=20.0, k_factor_db=6.0, freq_offset_hz=20.0)</code>  <code>staticmethod</code>","text":"<p>Mobile rural: Rician fading with LOS component.</p> <p>Typical for:</p> <ul> <li>Rural/suburban vehicular</li> <li>Partial line-of-sight</li> <li>Lower Doppler (lower speeds or frequencies)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 20 dB).</p> <code>20.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 20 Hz).</p> <code>20.0</code> <code>k_factor_db</code> <code>float</code> <p>Rician K-factor in dB (default: 6 dB).</p> <code>6.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 20 Hz).</p> <code>20.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef mobile_rural(\n  snr_db: float = 20.0,\n  doppler_hz: float = 20.0,\n  k_factor_db: float = 6.0,\n  freq_offset_hz: float = 20.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Mobile rural: Rician fading with LOS component.\n\n  Typical for:\n\n  - Rural/suburban vehicular\n  - Partial line-of-sight\n  - Lower Doppler (lower speeds or frequencies)\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 20 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 20 Hz).\n    k_factor_db: Rician K-factor in dB (default: 6 dB).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 20 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    RicianFading(doppler_hz=doppler_hz, k_factor_db=k_factor_db),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.channels.vhf.mobile_urban","title":"<code>mobile_urban(snr_db=15.0, doppler_hz=100.0, freq_offset_hz=50.0)</code>  <code>staticmethod</code>","text":"<p>Mobile urban: heavy Rayleigh fading, high Doppler.</p> <p>Typical for:</p> <ul> <li>Urban vehicular (60 km/h at 900 MHz \u2192 ~50 Hz Doppler)</li> <li>Dense multipath (buildings, reflections)</li> <li>Non-line-of-sight (NLOS)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>snr_db</code> <code>float</code> <p>Signal-to-noise ratio in dB (default: 15 dB).</p> <code>15.0</code> <code>doppler_hz</code> <code>float</code> <p>Maximum Doppler shift in Hz (default: 100 Hz).</p> <code>100.0</code> <code>freq_offset_hz</code> <code>float</code> <p>Carrier frequency offset in Hz (default: 50 Hz).</p> <code>50.0</code> <p>Returns:</p> Type Description <code>list[ChannelImpairment]</code> <p>List of channel impairments.</p> Source code in <code>src/shannon_bench/simulator/channels.py</code> <pre><code>@staticmethod\ndef mobile_urban(\n  snr_db: float = 15.0,\n  doppler_hz: float = 100.0,\n  freq_offset_hz: float = 50.0,\n) -&gt; list[ChannelImpairment]:\n  \"\"\"Mobile urban: heavy Rayleigh fading, high Doppler.\n\n  Typical for:\n\n  - Urban vehicular (60 km/h at 900 MHz \u2192 ~50 Hz Doppler)\n  - Dense multipath (buildings, reflections)\n  - Non-line-of-sight (NLOS)\n\n  Args:\n    snr_db: Signal-to-noise ratio in dB (default: 15 dB).\n    doppler_hz: Maximum Doppler shift in Hz (default: 100 Hz).\n    freq_offset_hz: Carrier frequency offset in Hz (default: 50 Hz).\n\n  Returns:\n    List of channel impairments.\n  \"\"\"\n  return [\n    # 3GPP EVA (Extended Vehicular A) model - simplified to 5 main taps\n    TappedDelayLine(\n      taps=[\n        TapProfile(\n          delay_sec=0.0,\n          power_db=0.0,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=30e-9,\n          power_db=-1.5,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=150e-9,\n          power_db=-1.4,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=310e-9,\n          power_db=-3.6,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n        TapProfile(\n          delay_sec=710e-9,\n          power_db=-9.1,\n          fading_model=RayleighFading(doppler_hz=doppler_hz),\n        ),\n      ]\n    ),\n    FreqOffset(offset_hz=freq_offset_hz),\n    AWGN(snr_db=snr_db),\n  ]\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system","title":"<code>shannon_bench.simulator.transmission_system</code>","text":"<p>Radio transmission system evaluation framework.</p> <p>This module provides a modular architecture for evaluating radio transmission systems by simulating the complete TX -&gt; Channel -&gt; RX chain and measuring Word Error Rate (WER) using ASR models like Whisper.</p> <p>The architecture consists of: - Transmitter: Converts audio to modulated RF signal - ChannelSimulator: Applies realistic channel impairments - Receiver: Demodulates RF signal back to audio - TransmissionSystem: Orchestrates the complete chain</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.AWGN","title":"<code>AWGN</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Additive White Gaussian Noise impairment.</p> <p>Adds thermal noise to the signal at a specified SNR.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class AWGN(BaseModel, ChannelImpairment):\n  \"\"\"Additive White Gaussian Noise impairment.\n\n  Adds thermal noise to the signal at a specified SNR.\n  \"\"\"\n\n  snr_db: float\n  seed: int | None = None\n\n  model_config = {\"frozen\": True}\n\n  def __init__(self, **data) -&gt; None:\n    super().__init__(**data)\n    self._rng = np.random.default_rng(self.seed)\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Add white Gaussian noise at specified SNR.\"\"\"\n    signal_power = np.mean(np.abs(signal) ** 2)\n    snr_linear = 10 ** (self.snr_db / 10)\n    noise_power = signal_power / snr_linear\n\n    # Complex AWGN: noise power split equally between I and Q\n    noise_std = np.sqrt(noise_power / 2)\n    noise = noise_std * (\n      self._rng.standard_normal(len(signal))\n      + 1j * self._rng.standard_normal(len(signal))\n    ).astype(np.complex64)\n\n    return signal + noise\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.NOISE\n\n  @property\n  def name(self) -&gt; str:\n    return f\"AWGN({self.snr_db}dB)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.AWGN.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Add white Gaussian noise at specified SNR.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Add white Gaussian noise at specified SNR.\"\"\"\n  signal_power = np.mean(np.abs(signal) ** 2)\n  snr_linear = 10 ** (self.snr_db / 10)\n  noise_power = signal_power / snr_linear\n\n  # Complex AWGN: noise power split equally between I and Q\n  noise_std = np.sqrt(noise_power / 2)\n  noise = noise_std * (\n    self._rng.standard_normal(len(signal))\n    + 1j * self._rng.standard_normal(len(signal))\n  ).astype(np.complex64)\n\n  return signal + noise\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelImpairment","title":"<code>ChannelImpairment</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for channel impairments.</p> <p>Each impairment represents a specific physical effect that can be applied to a signal. Impairments are automatically ordered by their stage to ensure physically realistic simulation.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class ChannelImpairment(ABC):\n  \"\"\"Abstract base class for channel impairments.\n\n  Each impairment represents a specific physical effect that can be applied\n  to a signal. Impairments are automatically ordered by their stage to ensure\n  physically realistic simulation.\n  \"\"\"\n\n  @abstractmethod\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply this impairment to the signal.\n\n    Args:\n      signal: Complex baseband signal.\n      sample_rate: Sample rate in Hz.\n\n    Returns:\n      Impaired signal.\n    \"\"\"\n\n  @property\n  @abstractmethod\n  def stage(self) -&gt; ImpairmentStage:\n    \"\"\"The stage at which this impairment is applied.\"\"\"\n\n  @property\n  @abstractmethod\n  def name(self) -&gt; str:\n    \"\"\"Human-readable name for this impairment.\"\"\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelImpairment.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Human-readable name for this impairment.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelImpairment.stage","title":"<code>stage</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The stage at which this impairment is applied.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelImpairment.apply","title":"<code>apply(signal, sample_rate)</code>  <code>abstractmethod</code>","text":"<p>Apply this impairment to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>NDArray[complex64]</code> <p>Complex baseband signal.</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz.</p> required <p>Returns:</p> Type Description <code>NDArray[complex64]</code> <p>Impaired signal.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>@abstractmethod\ndef apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply this impairment to the signal.\n\n  Args:\n    signal: Complex baseband signal.\n    sample_rate: Sample rate in Hz.\n\n  Returns:\n    Impaired signal.\n  \"\"\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelSimulator","title":"<code>ChannelSimulator</code>","text":"<p>Simulates realistic radio channel impairments using composable effects.</p> <p>This class applies channel impairments in a physically realistic order: 1. TRANSMITTER: SSB filter, PA nonlinearity, TX phase noise 2. CHANNEL: Fading, multipath 3. PROPAGATION: Frequency offset, Doppler 4. NOISE: AWGN</p> <p>Impairments are automatically sorted by stage regardless of input order.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class ChannelSimulator:\n  \"\"\"Simulates realistic radio channel impairments using composable effects.\n\n  This class applies channel impairments in a physically realistic order:\n  1. TRANSMITTER: SSB filter, PA nonlinearity, TX phase noise\n  2. CHANNEL: Fading, multipath\n  3. PROPAGATION: Frequency offset, Doppler\n  4. NOISE: AWGN\n\n  Impairments are automatically sorted by stage regardless of input order.\n  \"\"\"\n\n  def __init__(\n    self, impairments: Sequence[ChannelImpairment], sample_rate: int\n  ) -&gt; None:\n    \"\"\"Initialize channel simulator with impairments.\n\n    Args:\n      impairments: List of impairment objects to apply.\n      sample_rate: Sample rate of the signal in Hz.\n    \"\"\"\n    self.sample_rate = sample_rate\n\n    # Sort impairments by stage\n    original_names = [imp.name for imp in impairments]\n    self.impairments = sorted(impairments, key=lambda x: x.stage)\n    sorted_names = [imp.name for imp in self.impairments]\n\n    # Warn if order changed\n    if original_names != sorted_names:\n      logger.warning(\n        f\"Impairments reordered to canonical sequence:\\n\"\n        f\"  User order: {original_names}\\n\"\n        f\"  Canonical:  {sorted_names}\"\n      )\n\n  def apply(self, signal: npt.NDArray[np.complex64]) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply all impairments to signal in canonical order.\n\n    Args:\n      signal: Complex baseband signal.\n\n    Returns:\n      Impaired signal with same shape as input.\n    \"\"\"\n    result = signal.copy()\n\n    for impairment in self.impairments:\n      result = impairment.apply(result, self.sample_rate)\n\n    return result\n\n  @property\n  def name(self) -&gt; str:\n    \"\"\"Human-readable description of channel condition.\"\"\"\n    return \"_\".join(imp.name for imp in self.impairments)\n\n  @property\n  def snr_db(self) -&gt; float | None:\n    \"\"\"Get SNR in dB if AWGN impairment is present.\"\"\"\n    for imp in self.impairments:\n      if isinstance(imp, AWGN):\n        return imp.snr_db\n    return None\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelSimulator.name","title":"<code>name</code>  <code>property</code>","text":"<p>Human-readable description of channel condition.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelSimulator.snr_db","title":"<code>snr_db</code>  <code>property</code>","text":"<p>Get SNR in dB if AWGN impairment is present.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelSimulator.__init__","title":"<code>__init__(impairments, sample_rate)</code>","text":"<p>Initialize channel simulator with impairments.</p> <p>Parameters:</p> Name Type Description Default <code>impairments</code> <code>Sequence[ChannelImpairment]</code> <p>List of impairment objects to apply.</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate of the signal in Hz.</p> required Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def __init__(\n  self, impairments: Sequence[ChannelImpairment], sample_rate: int\n) -&gt; None:\n  \"\"\"Initialize channel simulator with impairments.\n\n  Args:\n    impairments: List of impairment objects to apply.\n    sample_rate: Sample rate of the signal in Hz.\n  \"\"\"\n  self.sample_rate = sample_rate\n\n  # Sort impairments by stage\n  original_names = [imp.name for imp in impairments]\n  self.impairments = sorted(impairments, key=lambda x: x.stage)\n  sorted_names = [imp.name for imp in self.impairments]\n\n  # Warn if order changed\n  if original_names != sorted_names:\n    logger.warning(\n      f\"Impairments reordered to canonical sequence:\\n\"\n      f\"  User order: {original_names}\\n\"\n      f\"  Canonical:  {sorted_names}\"\n    )\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ChannelSimulator.apply","title":"<code>apply(signal)</code>","text":"<p>Apply all impairments to signal in canonical order.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>NDArray[complex64]</code> <p>Complex baseband signal.</p> required <p>Returns:</p> Type Description <code>NDArray[complex64]</code> <p>Impaired signal with same shape as input.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(self, signal: npt.NDArray[np.complex64]) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply all impairments to signal in canonical order.\n\n  Args:\n    signal: Complex baseband signal.\n\n  Returns:\n    Impaired signal with same shape as input.\n  \"\"\"\n  result = signal.copy()\n\n  for impairment in self.impairments:\n    result = impairment.apply(result, self.sample_rate)\n\n  return result\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.FreqOffset","title":"<code>FreqOffset</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Carrier frequency offset impairment.</p> <p>Models LO mismatch between transmitter and receiver.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class FreqOffset(BaseModel, ChannelImpairment):\n  \"\"\"Carrier frequency offset impairment.\n\n  Models LO mismatch between transmitter and receiver.\n  \"\"\"\n\n  offset_hz: float\n\n  model_config = {\"frozen\": True}\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply carrier frequency offset.\"\"\"\n    if self.offset_hz == 0:\n      return signal\n\n    t = np.arange(len(signal), dtype=np.float64) / sample_rate\n    offset = np.exp(2j * np.pi * self.offset_hz * t).astype(np.complex64)\n    return signal * offset\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.PROPAGATION\n\n  @property\n  def name(self) -&gt; str:\n    return f\"FreqOffset({self.offset_hz}Hz)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.FreqOffset.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply carrier frequency offset.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply carrier frequency offset.\"\"\"\n  if self.offset_hz == 0:\n    return signal\n\n  t = np.arange(len(signal), dtype=np.float64) / sample_rate\n  offset = np.exp(2j * np.pi * self.offset_hz * t).astype(np.complex64)\n  return signal * offset\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.ImpairmentStage","title":"<code>ImpairmentStage</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Defines the canonical order of channel impairments.</p> <p>Impairments are applied in this order to match the physical reality of a radio transmission chain: 1. TRANSMITTER: TX-side impairments (filters, PA nonlinearity, TX phase noise) 2. CHANNEL: Propagation effects (fading, multipath) 3. PROPAGATION: Carrier effects (frequency offset, Doppler) 4. NOISE: Additive noise (AWGN) - always applied last</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class ImpairmentStage(IntEnum):\n  \"\"\"Defines the canonical order of channel impairments.\n\n  Impairments are applied in this order to match the physical reality\n  of a radio transmission chain:\n  1. TRANSMITTER: TX-side impairments (filters, PA nonlinearity, TX phase noise)\n  2. CHANNEL: Propagation effects (fading, multipath)\n  3. PROPAGATION: Carrier effects (frequency offset, Doppler)\n  4. NOISE: Additive noise (AWGN) - always applied last\n  \"\"\"\n\n  TRANSMITTER = 1\n  CHANNEL = 2\n  PROPAGATION = 3\n  NOISE = 4\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Nonlinearity","title":"<code>Nonlinearity</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Power amplifier nonlinearity using Rapp model.</p> <p>Implements the Rapp soft-clipping model for PA saturation. This models the AM/AM (amplitude-to-amplitude) characteristic of a solid-state PA.</p> The Rapp model <p>output = input / (1 + |input/A_sat|^(2p))^(1/2p)</p> Where <ul> <li>A_sat: Saturation amplitude (set by input_backoff_db)</li> <li>p: Smoothness parameter (higher = harder clipping)</li> </ul> References <ul> <li>C. Rapp, \"Effects of HPA-Nonlinearity on a 4-DPSK/OFDM-Signal for a   Digital Sound Broadcasting System\", ESA, 1991</li> </ul> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class Nonlinearity(BaseModel, ChannelImpairment):\n  \"\"\"Power amplifier nonlinearity using Rapp model.\n\n  Implements the Rapp soft-clipping model for PA saturation. This models\n  the AM/AM (amplitude-to-amplitude) characteristic of a solid-state PA.\n\n  The Rapp model:\n    output = input / (1 + |input/A_sat|^(2p))^(1/2p)\n\n  Where:\n    - A_sat: Saturation amplitude (set by input_backoff_db)\n    - p: Smoothness parameter (higher = harder clipping)\n\n  References:\n    - C. Rapp, \"Effects of HPA-Nonlinearity on a 4-DPSK/OFDM-Signal for a\n      Digital Sound Broadcasting System\", ESA, 1991\n  \"\"\"\n\n  input_backoff_db: float = Field(default=0.0, ge=0.0)\n  smoothness: float = Field(default=2.0, gt=0.0)\n\n  model_config = {\"frozen\": True}\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply Rapp model nonlinearity.\"\"\"\n    if self.input_backoff_db == 0:\n      # No saturation\n      return signal\n\n    # Calculate saturation amplitude from input backoff\n    # IBO (dB) = 20*log10(A_sat / A_in)\n    # For unit power signal, A_in \u2248 1, so A_sat = 10^(IBO/20)\n    a_sat = 10 ** (self.input_backoff_db / 20)\n\n    # Extract amplitude and phase\n    amplitude = np.abs(signal)\n    phase = np.angle(signal)\n\n    # Apply Rapp model to amplitude\n    # output_amp = input_amp / (1 + (input_amp/A_sat)^(2p))^(1/2p)\n    p = self.smoothness\n    ratio = amplitude / a_sat\n    compression_factor = 1.0 / (1.0 + ratio ** (2 * p)) ** (1.0 / (2 * p))\n    output_amplitude = amplitude * compression_factor\n\n    # Reconstruct signal (phase unchanged - AM/AM only, no AM/PM)\n    return (output_amplitude * np.exp(1j * phase)).astype(np.complex64)\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.TRANSMITTER\n\n  @property\n  def name(self) -&gt; str:\n    return f\"Nonlinearity(IBO={self.input_backoff_db}dB,p={self.smoothness})\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Nonlinearity.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply Rapp model nonlinearity.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply Rapp model nonlinearity.\"\"\"\n  if self.input_backoff_db == 0:\n    # No saturation\n    return signal\n\n  # Calculate saturation amplitude from input backoff\n  # IBO (dB) = 20*log10(A_sat / A_in)\n  # For unit power signal, A_in \u2248 1, so A_sat = 10^(IBO/20)\n  a_sat = 10 ** (self.input_backoff_db / 20)\n\n  # Extract amplitude and phase\n  amplitude = np.abs(signal)\n  phase = np.angle(signal)\n\n  # Apply Rapp model to amplitude\n  # output_amp = input_amp / (1 + (input_amp/A_sat)^(2p))^(1/2p)\n  p = self.smoothness\n  ratio = amplitude / a_sat\n  compression_factor = 1.0 / (1.0 + ratio ** (2 * p)) ** (1.0 / (2 * p))\n  output_amplitude = amplitude * compression_factor\n\n  # Reconstruct signal (phase unchanged - AM/AM only, no AM/PM)\n  return (output_amplitude * np.exp(1j * phase)).astype(np.complex64)\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.PhaseNoise","title":"<code>PhaseNoise</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Oscillator phase noise impairment.</p> <p>Models phase noise as a Wiener process (random walk phase). The phase step variance is determined by the level_dbchz parameter, which represents the phase noise density at a specific offset.</p> <p>Note: This is a simplified model assuming 1/f^2 spectrum (white FM noise).</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class PhaseNoise(BaseModel, ChannelImpairment):\n  \"\"\"Oscillator phase noise impairment.\n\n  Models phase noise as a Wiener process (random walk phase).\n  The phase step variance is determined by the level_dbchz parameter,\n  which represents the phase noise density at a specific offset.\n\n  Note: This is a simplified model assuming 1/f^2 spectrum (white FM noise).\n  \"\"\"\n\n  level_dbchz: float = Field(default=-80.0, le=0.0)\n  offset_hz: float = Field(default=1000.0, gt=0.0)\n  seed: int | None = None\n\n  model_config = {\"frozen\": True}\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply phase noise.\"\"\"\n    if self.level_dbchz &lt;= -170:\n      # Negligible noise\n      return signal\n\n    rng = np.random.default_rng(self.seed)\n\n    # Calculate phase variance per sample\n    # L(f) = 10*log10(S_phi(f)/2)\n    # S_phi(f) = C / f^2 for Wiener process\n    # C = 2 * 10^(L/10) * f_offset^2\n    # Variance per second = 2 * pi^2 * C\n    # Variance per sample = Variance per second / fs\n\n    l_linear = 10 ** (self.level_dbchz / 10)\n    c = 2 * l_linear * (self.offset_hz**2)\n    var_per_sample = (2 * np.pi**2 * c) / sample_rate\n    std_per_sample = np.sqrt(var_per_sample)\n\n    # Generate random phase steps\n    steps = rng.normal(0, std_per_sample, len(signal))\n\n    # Integrate to get phase (random walk)\n    phase_noise = np.cumsum(steps)\n\n    # Apply to signal\n    return (signal * np.exp(1j * phase_noise)).astype(np.complex64)\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.TRANSMITTER\n\n  @property\n  def name(self) -&gt; str:\n    return f\"PhaseNoise({self.level_dbchz}dBc/Hz)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.PhaseNoise.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply phase noise.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply phase noise.\"\"\"\n  if self.level_dbchz &lt;= -170:\n    # Negligible noise\n    return signal\n\n  rng = np.random.default_rng(self.seed)\n\n  # Calculate phase variance per sample\n  # L(f) = 10*log10(S_phi(f)/2)\n  # S_phi(f) = C / f^2 for Wiener process\n  # C = 2 * 10^(L/10) * f_offset^2\n  # Variance per second = 2 * pi^2 * C\n  # Variance per sample = Variance per second / fs\n\n  l_linear = 10 ** (self.level_dbchz / 10)\n  c = 2 * l_linear * (self.offset_hz**2)\n  var_per_sample = (2 * np.pi**2 * c) / sample_rate\n  std_per_sample = np.sqrt(var_per_sample)\n\n  # Generate random phase steps\n  steps = rng.normal(0, std_per_sample, len(signal))\n\n  # Integrate to get phase (random walk)\n  phase_noise = np.cumsum(steps)\n\n  # Apply to signal\n  return (signal * np.exp(1j * phase_noise)).astype(np.complex64)\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.RayleighFading","title":"<code>RayleighFading</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Rayleigh fading impairment using Jakes model.</p> <p>Implements flat Rayleigh fading with Doppler spread using the sum-of-sinusoids (Jakes) method. Models non-line-of-sight (NLOS) mobile or ionospheric channels.</p> References <ul> <li>W.C. Jakes, \"Microwave Mobile Communications\", 1974</li> <li>Y.R. Zheng &amp; C. Xiao, \"Improved models for the generation of multiple   uncorrelated Rayleigh fading waveforms\", IEEE Commun. Lett., 2002</li> </ul> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class RayleighFading(BaseModel, ChannelImpairment):\n  \"\"\"Rayleigh fading impairment using Jakes model.\n\n  Implements flat Rayleigh fading with Doppler spread using the\n  sum-of-sinusoids (Jakes) method. Models non-line-of-sight (NLOS)\n  mobile or ionospheric channels.\n\n  References:\n    - W.C. Jakes, \"Microwave Mobile Communications\", 1974\n    - Y.R. Zheng &amp; C. Xiao, \"Improved models for the generation of multiple\n      uncorrelated Rayleigh fading waveforms\", IEEE Commun. Lett., 2002\n  \"\"\"\n\n  doppler_hz: float = Field(default=0.0, ge=0.0)\n  num_sinusoids: int = 16\n  seed: int | None = None\n\n  model_config = {\"frozen\": True}\n\n  def __init__(self, **data) -&gt; None:\n    super().__init__(**data)\n    self._rng = np.random.default_rng(self.seed)\n    self._setup_jakes_oscillators()\n\n  def _setup_jakes_oscillators(self) -&gt; None:\n    \"\"\"Initialize Jakes model oscillators for fading generation.\"\"\"\n    if self.doppler_hz == 0:\n      self._oscillators = None\n      return\n\n    n_sinusoids = self.num_sinusoids\n\n    # Generate random phases (uniformly distributed)\n    self._phases = self._rng.uniform(0, 2 * np.pi, n_sinusoids)\n\n    # Generate Doppler frequencies using Jakes spectrum\n    # f_n = f_d * cos(2\u03c0 n / N) for n = 1, 2, ..., N\n    n = np.arange(1, n_sinusoids + 1)\n    self._doppler_freqs = self.doppler_hz * np.cos(2 * np.pi * n / n_sinusoids)\n\n    # Amplitudes (normalized so E[|h|^2] = 1 for Rayleigh)\n    # cos and sin have variance 1/2, so we need sqrt(2) factor\n    self._amplitudes = np.ones(n_sinusoids) * np.sqrt(2.0 / n_sinusoids)\n\n    self._oscillators = True\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply Rayleigh fading using Jakes model.\"\"\"\n    if self.doppler_hz == 0 or self._oscillators is None:\n      return signal\n\n    t = np.arange(len(signal), dtype=np.float64) / sample_rate\n\n    # Generate I and Q components separately\n    h_i = np.zeros(len(signal), dtype=np.float64)\n    h_q = np.zeros(len(signal), dtype=np.float64)\n\n    for amp, freq, phase in zip(\n      self._amplitudes, self._doppler_freqs, self._phases, strict=False\n    ):\n      h_i += amp * np.cos(2 * np.pi * freq * t + phase)\n      h_q += amp * np.sin(2 * np.pi * freq * t + phase)\n\n    h = (h_i + 1j * h_q).astype(np.complex128)\n\n    return (signal * h).astype(np.complex64)\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.CHANNEL\n\n  @property\n  def name(self) -&gt; str:\n    return f\"Rayleigh(fd={self.doppler_hz}Hz)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.RayleighFading.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply Rayleigh fading using Jakes model.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply Rayleigh fading using Jakes model.\"\"\"\n  if self.doppler_hz == 0 or self._oscillators is None:\n    return signal\n\n  t = np.arange(len(signal), dtype=np.float64) / sample_rate\n\n  # Generate I and Q components separately\n  h_i = np.zeros(len(signal), dtype=np.float64)\n  h_q = np.zeros(len(signal), dtype=np.float64)\n\n  for amp, freq, phase in zip(\n    self._amplitudes, self._doppler_freqs, self._phases, strict=False\n  ):\n    h_i += amp * np.cos(2 * np.pi * freq * t + phase)\n    h_q += amp * np.sin(2 * np.pi * freq * t + phase)\n\n  h = (h_i + 1j * h_q).astype(np.complex128)\n\n  return (signal * h).astype(np.complex64)\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Receiver","title":"<code>Receiver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for radio receivers.</p> <p>A receiver demodulates received RF (baseband I/Q) signals back into audio.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class Receiver(ABC):\n  \"\"\"Abstract base class for radio receivers.\n\n  A receiver demodulates received RF (baseband I/Q) signals back into audio.\n  \"\"\"\n\n  @abstractmethod\n  def demodulate(\n    self, signal: npt.NDArray[np.complex64], input_sample_rate: int\n  ) -&gt; npt.NDArray[np.float32]:\n    \"\"\"Convert received RF signal back to audio.\n\n    Args:\n      signal: Complex baseband signal (I/Q samples).\n      input_sample_rate: Signal sample rate in Hz.\n\n    Returns:\n      Demodulated audio (mono, float32, normalized to [-1, 1]).\n    \"\"\"\n\n  @property\n  @abstractmethod\n  def name(self) -&gt; str:\n    \"\"\"Human-readable receiver name for reporting.\"\"\"\n\n  @property\n  @abstractmethod\n  def output_sample_rate(self) -&gt; int:\n    \"\"\"Sample rate of demodulated audio in Hz.\"\"\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Receiver.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Human-readable receiver name for reporting.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.Receiver.output_sample_rate","title":"<code>output_sample_rate</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Sample rate of demodulated audio in Hz.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.Receiver.demodulate","title":"<code>demodulate(signal, input_sample_rate)</code>  <code>abstractmethod</code>","text":"<p>Convert received RF signal back to audio.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>NDArray[complex64]</code> <p>Complex baseband signal (I/Q samples).</p> required <code>input_sample_rate</code> <code>int</code> <p>Signal sample rate in Hz.</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Demodulated audio (mono, float32, normalized to [-1, 1]).</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>@abstractmethod\ndef demodulate(\n  self, signal: npt.NDArray[np.complex64], input_sample_rate: int\n) -&gt; npt.NDArray[np.float32]:\n  \"\"\"Convert received RF signal back to audio.\n\n  Args:\n    signal: Complex baseband signal (I/Q samples).\n    input_sample_rate: Signal sample rate in Hz.\n\n  Returns:\n    Demodulated audio (mono, float32, normalized to [-1, 1]).\n  \"\"\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.RicianFading","title":"<code>RicianFading</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Rician fading impairment using Jakes model.</p> <p>Implements Rician fading with Doppler spread and a line-of-sight (LOS) component. The K-factor controls the ratio of LOS to scattered power.</p> <p>K-factor (dB):   - 0 dB: Equal LOS and scattered power   - 10 dB: Strong LOS (satellite, rural)   - -\u221e dB: No LOS (reduces to Rayleigh)</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class RicianFading(BaseModel, ChannelImpairment):\n  \"\"\"Rician fading impairment using Jakes model.\n\n  Implements Rician fading with Doppler spread and a line-of-sight (LOS)\n  component. The K-factor controls the ratio of LOS to scattered power.\n\n  K-factor (dB):\n    - 0 dB: Equal LOS and scattered power\n    - 10 dB: Strong LOS (satellite, rural)\n    - -\u221e dB: No LOS (reduces to Rayleigh)\n  \"\"\"\n\n  doppler_hz: float = Field(default=0.0, ge=0.0)\n  k_factor_db: float\n  num_sinusoids: int = 16\n  seed: int | None = None\n\n  model_config = {\"frozen\": True}\n\n  def __init__(self, **data) -&gt; None:\n    super().__init__(**data)\n    self._rng = np.random.default_rng(self.seed)\n    self._setup_jakes_oscillators()\n\n  def _setup_jakes_oscillators(self) -&gt; None:\n    \"\"\"Initialize Jakes model oscillators for fading generation.\"\"\"\n    if self.doppler_hz == 0:\n      self._oscillators = None\n      return\n\n    n_sinusoids = self.num_sinusoids\n\n    # Generate random phases\n    self._phases = self._rng.uniform(0, 2 * np.pi, n_sinusoids)\n\n    # Doppler frequencies\n    n = np.arange(1, n_sinusoids + 1)\n    self._doppler_freqs = self.doppler_hz * np.cos(2 * np.pi * n / n_sinusoids)\n\n    # Amplitudes for scattered component\n    self._amplitudes = np.ones(n_sinusoids) * np.sqrt(2.0 / n_sinusoids)\n\n    # LOS component scaling\n    k_linear = 10 ** (self.k_factor_db / 10)\n    self._los_amplitude = np.sqrt(k_linear / (k_linear + 1))\n    self._scatter_scale = np.sqrt(1 / (k_linear + 1))\n    self._los_phase = self._rng.uniform(0, 2 * np.pi)\n\n    self._oscillators = True\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply Rician fading using Jakes model.\"\"\"\n    if self.doppler_hz == 0 or self._oscillators is None:\n      return signal\n\n    t = np.arange(len(signal), dtype=np.float64) / sample_rate\n\n    # Generate scattered component (Rayleigh)\n    h_i = np.zeros(len(signal), dtype=np.float64)\n    h_q = np.zeros(len(signal), dtype=np.float64)\n\n    for amp, freq, phase in zip(\n      self._amplitudes, self._doppler_freqs, self._phases, strict=False\n    ):\n      h_i += amp * np.cos(2 * np.pi * freq * t + phase)\n      h_q += amp * np.sin(2 * np.pi * freq * t + phase)\n\n    h_scatter = (h_i + 1j * h_q).astype(np.complex128)\n\n    # Add LOS component\n    h_los = self._los_amplitude * np.exp(1j * self._los_phase)\n    h = h_los + self._scatter_scale * h_scatter\n\n    return (signal * h).astype(np.complex64)\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.CHANNEL\n\n  @property\n  def name(self) -&gt; str:\n    return f\"Rician(K={self.k_factor_db}dB,fd={self.doppler_hz}Hz)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.RicianFading.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply Rician fading using Jakes model.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply Rician fading using Jakes model.\"\"\"\n  if self.doppler_hz == 0 or self._oscillators is None:\n    return signal\n\n  t = np.arange(len(signal), dtype=np.float64) / sample_rate\n\n  # Generate scattered component (Rayleigh)\n  h_i = np.zeros(len(signal), dtype=np.float64)\n  h_q = np.zeros(len(signal), dtype=np.float64)\n\n  for amp, freq, phase in zip(\n    self._amplitudes, self._doppler_freqs, self._phases, strict=False\n  ):\n    h_i += amp * np.cos(2 * np.pi * freq * t + phase)\n    h_q += amp * np.sin(2 * np.pi * freq * t + phase)\n\n  h_scatter = (h_i + 1j * h_q).astype(np.complex128)\n\n  # Add LOS component\n  h_los = self._los_amplitude * np.exp(1j * self._los_phase)\n  h = h_los + self._scatter_scale * h_scatter\n\n  return (signal * h).astype(np.complex64)\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.SSBFilter","title":"<code>SSBFilter</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>SSB bandpass filter impairment.</p> <p>Models the typical 300-2700 Hz filter found in HF transceivers.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class SSBFilter(BaseModel, ChannelImpairment):\n  \"\"\"SSB bandpass filter impairment.\n\n  Models the typical 300-2700 Hz filter found in HF transceivers.\n  \"\"\"\n\n  low_cutoff_hz: float = 300.0\n  high_cutoff_hz: float = 2700.0\n  filter_order: int = 5\n\n  model_config = {\"frozen\": True}\n\n  def __init__(self, **data) -&gt; None:\n    super().__init__(**data)\n    self._sos_cache: dict[int, npt.NDArray] = {}\n\n  def _get_filter_sos(self, sample_rate: int) -&gt; npt.NDArray:\n    \"\"\"Get or create filter coefficients for given sample rate.\"\"\"\n    if sample_rate not in self._sos_cache:\n      nyquist = 0.5 * sample_rate\n      low = self.low_cutoff_hz / nyquist\n      high = self.high_cutoff_hz / nyquist\n\n      if low &lt;= 0 or high &gt;= 1 or low &gt;= high:\n        msg = (\n          f\"Invalid filter cutoffs: {self.low_cutoff_hz}-{self.high_cutoff_hz} Hz \"\n          f\"for sample rate {sample_rate} Hz\"\n        )\n        raise ValueError(msg)\n\n      # Calculate required order for 30dB stopband attenuation\n      # Transition width: 100 Hz\n      transition = 100.0 / nyquist\n\n      # Ensure transition doesn't go below DC or above Nyquist\n      ws_low = max(0.001, low - transition)\n      ws_high = min(0.999, high + transition)\n\n      # Use cheb2ord to find minimum order for Chebyshev Type II\n      # Cheby2 has flat passband (no ripple) and equiripple stopband\n      # gpass=3dB (passband corner attenuation), gstop=30dB (stopband attenuation)\n      filter_order, wn = scipy_signal.cheb2ord(\n        [low, high], [ws_low, ws_high], gpass=3, gstop=30, fs=None\n      )\n\n      # Cap order to avoid extreme values\n      filter_order = min(filter_order, 20)\n\n      # Use Chebyshev Type II filter\n      # rs is the stopband attenuation in dB\n      self._sos_cache[sample_rate] = scipy_signal.cheby2(\n        filter_order, rs=30, Wn=wn, btype=\"band\", output=\"sos\"\n      )\n\n    return self._sos_cache[sample_rate]\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply SSB bandpass filter.\"\"\"\n    sos = self._get_filter_sos(sample_rate)\n\n    # Filter I and Q independently\n    filtered_real = scipy_signal.sosfilt(sos, signal.real)\n    filtered_imag = scipy_signal.sosfilt(sos, signal.imag)\n\n    return (filtered_real + 1j * filtered_imag).astype(np.complex64)\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.TRANSMITTER\n\n  @property\n  def name(self) -&gt; str:\n    return f\"SSB({int(self.low_cutoff_hz)}-{int(self.high_cutoff_hz)}Hz)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.SSBFilter.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply SSB bandpass filter.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply SSB bandpass filter.\"\"\"\n  sos = self._get_filter_sos(sample_rate)\n\n  # Filter I and Q independently\n  filtered_real = scipy_signal.sosfilt(sos, signal.real)\n  filtered_imag = scipy_signal.sosfilt(sos, signal.imag)\n\n  return (filtered_real + 1j * filtered_imag).astype(np.complex64)\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TapProfile","title":"<code>TapProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a single channel tap in a Tapped Delay Line model.</p> <p>Attributes:</p> Name Type Description <code>delay_sec</code> <code>float</code> <p>Delay of this tap relative to the first tap in seconds.</p> <code>power_db</code> <code>float</code> <p>Average power of this tap relative to the strongest tap in dB.         (Usually 0 dB for the first/strongest tap, negative for others)</p> <code>fading_model</code> <code>RayleighFading | RicianFading | None</code> <p>Optional fading model (Rayleigh/Rician) to apply to this tap.             If None, the tap is static (no fading).</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class TapProfile(BaseModel):\n  \"\"\"Configuration for a single channel tap in a Tapped Delay Line model.\n\n  Attributes:\n    delay_sec: Delay of this tap relative to the first tap in seconds.\n    power_db: Average power of this tap relative to the strongest tap in dB.\n              (Usually 0 dB for the first/strongest tap, negative for others)\n    fading_model: Optional fading model (Rayleigh/Rician) to apply to this tap.\n                  If None, the tap is static (no fading).\n  \"\"\"\n\n  delay_sec: float = Field(ge=0.0)\n  power_db: float = Field(le=0.0)\n  fading_model: RayleighFading | RicianFading | None = None\n\n  model_config = {\"frozen\": True}\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TappedDelayLine","title":"<code>TappedDelayLine</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ChannelImpairment</code></p> <p>Multipath channel simulator using Tapped Delay Line (TDL) model.</p> <p>Simulates frequency-selective fading by summing multiple delayed and independently faded copies of the signal. This models the physical reality of multipath propagation where signals arrive via different paths with different delays and Doppler shifts.</p> The output signal is <p>y(t) = sum( h_i(t) * x(t - tau_i) )</p> Where <ul> <li>x(t) is the input signal</li> <li>tau_i is the delay of the i-th tap</li> <li>h_i(t) is the complex channel coefficient for the i-th tap (includes   power scaling and fading)</li> </ul> Note <p>This implementation uses integer sample delays (<code>int(round(delay * fs))</code>). For narrowband signals (low sample rates) or very small delays (nanoseconds), multiple taps may collapse into a single tap (flat fading). This is physically correct for narrowband simulations where the signal bandwidth cannot resolve the multipath delay spread.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class TappedDelayLine(BaseModel, ChannelImpairment):\n  \"\"\"Multipath channel simulator using Tapped Delay Line (TDL) model.\n\n  Simulates frequency-selective fading by summing multiple delayed and\n  independently faded copies of the signal. This models the physical reality\n  of multipath propagation where signals arrive via different paths with\n  different delays and Doppler shifts.\n\n  The output signal is:\n    y(t) = sum( h_i(t) * x(t - tau_i) )\n\n  Where:\n    - x(t) is the input signal\n    - tau_i is the delay of the i-th tap\n    - h_i(t) is the complex channel coefficient for the i-th tap (includes\n      power scaling and fading)\n\n  Note:\n    This implementation uses integer sample delays (`int(round(delay * fs))`).\n    For narrowband signals (low sample rates) or very small delays (nanoseconds),\n    multiple taps may collapse into a single tap (flat fading). This is\n    physically correct for narrowband simulations where the signal bandwidth\n    cannot resolve the multipath delay spread.\n  \"\"\"\n\n  taps: Sequence[TapProfile]\n  normalize_power: bool = True\n\n  model_config = {\"frozen\": True}\n\n  def apply(\n    self, signal: npt.NDArray[np.complex64], sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Apply Tapped Delay Line multipath model.\"\"\"\n    if not self.taps:\n      return signal\n\n    output_signal = np.zeros_like(signal)\n    total_power_linear = 0.0\n\n    for tap in self.taps:\n      # 1. Calculate linear power scale\n      power_linear = 10 ** (tap.power_db / 10)\n      total_power_linear += power_linear\n      amplitude_scale = np.sqrt(power_linear)\n\n      # 2. Apply delay\n      # Convert delay from seconds to samples\n      delay_samples = tap.delay_sec * sample_rate\n\n      # Use integer delay for simplicity and efficiency\n      # (Fractional delay would require sinc interpolation, which is\n      # computationally expensive and maybe overkill for this simulation\n      # level, but can be added if needed)\n      delay_int = round(delay_samples)\n\n      if delay_int == 0:\n        delayed_signal = signal\n      elif delay_int &gt;= len(signal):\n        # Delay is longer than signal, contribution is zero\n        delayed_signal = np.zeros_like(signal)\n      else:\n        # Shift signal\n        delayed_signal = np.zeros_like(signal)\n        delayed_signal[delay_int:] = signal[:-delay_int]\n\n      # 3. Apply fading (if configured)\n      if tap.fading_model:\n        # Apply fading to the delayed signal\n        # Note: We pass sample_rate to the fading model so it generates correct Doppler\n        faded_signal = tap.fading_model.apply(delayed_signal, sample_rate)\n      else:\n        faded_signal = delayed_signal\n\n      # 4. Accumulate\n      output_signal += amplitude_scale * faded_signal\n\n    # 5. Normalize total power if requested\n    # This ensures the channel doesn't amplify or attenuate the total\n    # signal energy on average\n    if self.normalize_power and total_power_linear &gt; 0:\n      output_signal /= np.sqrt(total_power_linear)\n\n    return output_signal\n\n  @property\n  def stage(self) -&gt; ImpairmentStage:\n    return ImpairmentStage.CHANNEL\n\n  @property\n  def name(self) -&gt; str:\n    return f\"TDL({len(self.taps)} taps)\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TappedDelayLine.apply","title":"<code>apply(signal, sample_rate)</code>","text":"<p>Apply Tapped Delay Line multipath model.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def apply(\n  self, signal: npt.NDArray[np.complex64], sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Apply Tapped Delay Line multipath model.\"\"\"\n  if not self.taps:\n    return signal\n\n  output_signal = np.zeros_like(signal)\n  total_power_linear = 0.0\n\n  for tap in self.taps:\n    # 1. Calculate linear power scale\n    power_linear = 10 ** (tap.power_db / 10)\n    total_power_linear += power_linear\n    amplitude_scale = np.sqrt(power_linear)\n\n    # 2. Apply delay\n    # Convert delay from seconds to samples\n    delay_samples = tap.delay_sec * sample_rate\n\n    # Use integer delay for simplicity and efficiency\n    # (Fractional delay would require sinc interpolation, which is\n    # computationally expensive and maybe overkill for this simulation\n    # level, but can be added if needed)\n    delay_int = round(delay_samples)\n\n    if delay_int == 0:\n      delayed_signal = signal\n    elif delay_int &gt;= len(signal):\n      # Delay is longer than signal, contribution is zero\n      delayed_signal = np.zeros_like(signal)\n    else:\n      # Shift signal\n      delayed_signal = np.zeros_like(signal)\n      delayed_signal[delay_int:] = signal[:-delay_int]\n\n    # 3. Apply fading (if configured)\n    if tap.fading_model:\n      # Apply fading to the delayed signal\n      # Note: We pass sample_rate to the fading model so it generates correct Doppler\n      faded_signal = tap.fading_model.apply(delayed_signal, sample_rate)\n    else:\n      faded_signal = delayed_signal\n\n    # 4. Accumulate\n    output_signal += amplitude_scale * faded_signal\n\n  # 5. Normalize total power if requested\n  # This ensures the channel doesn't amplify or attenuate the total\n  # signal energy on average\n  if self.normalize_power and total_power_linear &gt; 0:\n    output_signal /= np.sqrt(total_power_linear)\n\n  return output_signal\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TransmissionSystem","title":"<code>TransmissionSystem</code>","text":"<p>Complete radio transmission system: TX -&gt; Channel -&gt; RX.</p> <p>This class orchestrates the complete signal chain from audio input through modulation, channel impairments, and demodulation back to audio.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class TransmissionSystem:\n  \"\"\"Complete radio transmission system: TX -&gt; Channel -&gt; RX.\n\n  This class orchestrates the complete signal chain from audio input through\n  modulation, channel impairments, and demodulation back to audio.\n  \"\"\"\n\n  def __init__(\n    self, transmitter: Transmitter, receiver: Receiver, channel: ChannelSimulator\n  ) -&gt; None:\n    \"\"\"Initialize transmission system.\n\n    Args:\n      transmitter: Transmitter instance.\n      receiver: Receiver instance.\n      channel: Channel simulator instance.\n    \"\"\"\n    self.transmitter = transmitter\n    self.receiver = receiver\n    self.channel = channel\n\n  def process(\n    self, audio: npt.NDArray[np.float32], audio_sample_rate: int\n  ) -&gt; npt.NDArray[np.float32]:\n    \"\"\"Process audio through complete TX -&gt; Channel -&gt; RX chain.\n\n    Args:\n      audio: Input audio samples (mono, float32, normalized to [-1, 1]).\n      audio_sample_rate: Audio sample rate in Hz.\n\n    Returns:\n      Received audio after channel impairments, at receiver's output sample rate.\n    \"\"\"\n    # Transmit\n    modulated = self.transmitter.modulate(audio, audio_sample_rate)\n\n    # Channel\n    received_signal = self.channel.apply(modulated)\n\n    # Receive\n    return self.receiver.demodulate(\n      received_signal, self.transmitter.output_sample_rate\n    )\n\n  @property\n  def name(self) -&gt; str:\n    \"\"\"System name for reporting (TX_RX format).\"\"\"\n    return f\"{self.transmitter.name}_{self.receiver.name}\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TransmissionSystem.name","title":"<code>name</code>  <code>property</code>","text":"<p>System name for reporting (TX_RX format).</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.TransmissionSystem.__init__","title":"<code>__init__(transmitter, receiver, channel)</code>","text":"<p>Initialize transmission system.</p> <p>Parameters:</p> Name Type Description Default <code>transmitter</code> <code>Transmitter</code> <p>Transmitter instance.</p> required <code>receiver</code> <code>Receiver</code> <p>Receiver instance.</p> required <code>channel</code> <code>ChannelSimulator</code> <p>Channel simulator instance.</p> required Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def __init__(\n  self, transmitter: Transmitter, receiver: Receiver, channel: ChannelSimulator\n) -&gt; None:\n  \"\"\"Initialize transmission system.\n\n  Args:\n    transmitter: Transmitter instance.\n    receiver: Receiver instance.\n    channel: Channel simulator instance.\n  \"\"\"\n  self.transmitter = transmitter\n  self.receiver = receiver\n  self.channel = channel\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.TransmissionSystem.process","title":"<code>process(audio, audio_sample_rate)</code>","text":"<p>Process audio through complete TX -&gt; Channel -&gt; RX chain.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>NDArray[float32]</code> <p>Input audio samples (mono, float32, normalized to [-1, 1]).</p> required <code>audio_sample_rate</code> <code>int</code> <p>Audio sample rate in Hz.</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Received audio after channel impairments, at receiver's output sample rate.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>def process(\n  self, audio: npt.NDArray[np.float32], audio_sample_rate: int\n) -&gt; npt.NDArray[np.float32]:\n  \"\"\"Process audio through complete TX -&gt; Channel -&gt; RX chain.\n\n  Args:\n    audio: Input audio samples (mono, float32, normalized to [-1, 1]).\n    audio_sample_rate: Audio sample rate in Hz.\n\n  Returns:\n    Received audio after channel impairments, at receiver's output sample rate.\n  \"\"\"\n  # Transmit\n  modulated = self.transmitter.modulate(audio, audio_sample_rate)\n\n  # Channel\n  received_signal = self.channel.apply(modulated)\n\n  # Receive\n  return self.receiver.demodulate(\n    received_signal, self.transmitter.output_sample_rate\n  )\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Transmitter","title":"<code>Transmitter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for radio transmitters.</p> <p>A transmitter converts audio signals into modulated RF (baseband I/Q) signals suitable for transmission over a radio channel.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>class Transmitter(ABC):\n  \"\"\"Abstract base class for radio transmitters.\n\n  A transmitter converts audio signals into modulated RF (baseband I/Q) signals\n  suitable for transmission over a radio channel.\n  \"\"\"\n\n  @abstractmethod\n  def modulate(\n    self, audio: npt.NDArray[np.float32], input_sample_rate: int\n  ) -&gt; npt.NDArray[np.complex64]:\n    \"\"\"Convert audio to modulated RF signal.\n\n    Args:\n      audio: Input audio samples (mono, float32, normalized to [-1, 1]).\n      input_sample_rate: Audio sample rate in Hz.\n\n    Returns:\n      Complex baseband signal (I/Q samples) at the transmitter's output sample rate.\n    \"\"\"\n\n  @property\n  @abstractmethod\n  def name(self) -&gt; str:\n    \"\"\"Human-readable transmitter name for reporting.\"\"\"\n\n  @property\n  @abstractmethod\n  def bandwidth_hz(self) -&gt; float:\n    \"\"\"Signal bandwidth in Hz (occupied bandwidth).\"\"\"\n\n  @property\n  @abstractmethod\n  def output_sample_rate(self) -&gt; int:\n    \"\"\"Sample rate of modulated output in Hz.\"\"\"\n</code></pre>"},{"location":"api/#shannon_bench.simulator.transmission_system.Transmitter.bandwidth_hz","title":"<code>bandwidth_hz</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Signal bandwidth in Hz (occupied bandwidth).</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.Transmitter.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Human-readable transmitter name for reporting.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.Transmitter.output_sample_rate","title":"<code>output_sample_rate</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Sample rate of modulated output in Hz.</p>"},{"location":"api/#shannon_bench.simulator.transmission_system.Transmitter.modulate","title":"<code>modulate(audio, input_sample_rate)</code>  <code>abstractmethod</code>","text":"<p>Convert audio to modulated RF signal.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>NDArray[float32]</code> <p>Input audio samples (mono, float32, normalized to [-1, 1]).</p> required <code>input_sample_rate</code> <code>int</code> <p>Audio sample rate in Hz.</p> required <p>Returns:</p> Type Description <code>NDArray[complex64]</code> <p>Complex baseband signal (I/Q samples) at the transmitter's output sample rate.</p> Source code in <code>src/shannon_bench/simulator/transmission_system.py</code> <pre><code>@abstractmethod\ndef modulate(\n  self, audio: npt.NDArray[np.float32], input_sample_rate: int\n) -&gt; npt.NDArray[np.complex64]:\n  \"\"\"Convert audio to modulated RF signal.\n\n  Args:\n    audio: Input audio samples (mono, float32, normalized to [-1, 1]).\n    input_sample_rate: Audio sample rate in Hz.\n\n  Returns:\n    Complex baseband signal (I/Q samples) at the transmitter's output sample rate.\n  \"\"\"\n</code></pre>"}]}